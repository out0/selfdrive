import sys, time
sys.path.append("../../")
sys.path.append("../")
sys.path.append("/home/cristiano/Documents/Projects/Mestrado/code/driveless-new/libdriveless")
import unittest, math, numpy as np
import matplotlib.pyplot as plt
from pydriveless.search_frame import SearchFrame
import cv2

#LIB_DRIVELESS_PATH="../../libdriveless.so"
LIB_DRIVELESS_PATH="/home/cristiano/Documents/Projects/Mestrado/code/driveless-new/libdriveless/libdriveless.so"

class TestSearchFrameSetGoal(unittest.TestCase):
    
    def check_expected_obtained_grid(self, frame: SearchFrame, expected: np.ndarray):

        width = frame.width()
        
        for j in range(frame.height()):
            for i in range(width):
                obtained = frame.get_traversability(i, j)
                if (expected[j, i] != obtained):
                    print(f"angle value on {i}, {j} expected {expected[j, i]} obtained {obtained}");
                    self.fail()
    
    def build_frame(self, grid: np.ndarray, dist: tuple[int, int]):
        width = grid.shape[1]
        height = grid.shape[0]
        frame = SearchFrame(width, height, dist, [-1,-1], [-1,-1], LIB_DRIVELESS_PATH)
        fptr = np.zeros((height, width, 3), dtype=np.float32)

        for h in range(height):
            for w in range(width):

                fptr[h, w, 0] = 1
                if grid[h, w] == 1:
                    fptr[h, w, 0] = 0 # obstacle

                fptr[h, w, 1] = 0
                fptr[h, w, 2] = 0
        
        frame.set_frame_data(fptr)
        frame.set_class_costs(np.array([-1, 2], dtype=np.int32))
        return frame
    
    def euclidean_dist(self, p1: tuple[int, int], p2: tuple[int, int]):
        dx = p1[0] - p2[0]
        dz = p1[1] - p2[1]
        return math.sqrt(dx * dx + dz * dz)

   
    def test_costs(self):
        grid = np.array([
          # 0  1  2  3  4  5  6  7  8  9  10
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ] #
        ])
        
        frame = self.build_frame(grid=grid, dist=(0, 0))
        frame.set_goal(5, 0)
        

        for h in range(frame.height()):
            for w in range(frame.height()):
                expected = self.euclidean_dist((w, h), (5, 0))
                
                if grid[h, w] == 0:
                    expected = frame.get_class_cost(1) * self.euclidean_dist ((w, h), (5, 0))
                
                obtained = frame.get_cost(w, h)

                if (abs(expected - obtained) > 0.0001):
                    print(f"SetGoal cost failed for position {w}, {h}: expected {expected} obtained {obtained}")
                    self.fail()
    
    def test_no_margins(self):
        grid = np.array([
          # 0  1  2  3  4  5  6  7  8  9  10
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ] #
        ])
        
        A = 0xff
        expected = np.array([
          # 0  1  2  3  4  5  6  7  8  9  10
            [ 0, 0, 0, A, A, A, A, A, 0, 0, 0 ], #
            [ 0, 0, 0, A, A, A, A, A, 0, 0, 0 ], #
            [ 0, 0, 0, A, A, A, A, A, 0, 0, 0 ], #
            [ 0, 0, 0, A, A, A, A, A, 0, 0, 0 ], #
            [ 0, 0, 0, A, A, A, A, A, 0, 0, 0 ], #
            [ 0, 0, 0, A, A, A, A, A, 0, 0, 0 ], #
            [ 0, 0, 0, A, A, A, A, A, 0, 0, 0 ], #
            [ 0, 0, 0, A, A, A, A, A, 0, 0, 0 ], #
            [ 0, 0, 0, A, A, A, A, A, 0, 0, 0 ], #
            [ 0, 0, 0, A, A, A, A, A, 0, 0, 0 ], #
            [ 0, 0, 0, A, A, A, A, A, 0, 0, 0 ], #
        ])
        
        dist = (0, 0)
        frame = self.build_frame(grid=grid, dist=dist)
        frame.set_goal(5, 0)
        self.check_expected_obtained_grid(frame, expected)

    def test_with_margins(self):
        grid = np.array([
          # 0  1  2  3  4  5  6  7  8  9  10
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ] #
        ])
        
        A = 0xff
        p04 = SearchFrame.HEADING_MINUS_45 | SearchFrame.HEADING_MINUS_22_5 | SearchFrame.HEADING_0
        p06 = SearchFrame.HEADING_45 | SearchFrame.HEADING_22_5 | SearchFrame.HEADING_0
        Z = SearchFrame.HEADING_0
        pA4 = SearchFrame.HEADING_45 | SearchFrame.HEADING_22_5 | SearchFrame.HEADING_0
        pA6 = SearchFrame.HEADING_MINUS_45 | SearchFrame.HEADING_MINUS_22_5 | SearchFrame.HEADING_0
        
        
        expected = np.array([
         # 0  1  2  3  4  5  6  7  8  9  10
         [ 0, 0, 0, 0, p04, A, p06, 0, 0, 0, 0 ], #
         [ 0, 0, 0, 0, Z, A, Z, 0, 0, 0, 0 ],     #
         [ 0, 0, 0, 0, Z, A, Z, 0, 0, 0, 0 ],     #
         [ 0, 0, 0, 0, Z, A, Z, 0, 0, 0, 0 ],     #
         [ 0, 0, 0, 0, Z, A, Z, 0, 0, 0, 0 ],     #
         [ 0, 0, 0, 0, Z, A, Z, 0, 0, 0, 0 ],     #
         [ 0, 0, 0, 0, Z, A, Z, 0, 0, 0, 0 ],     #
         [ 0, 0, 0, 0, Z, A, Z, 0, 0, 0, 0 ],     #
         [ 0, 0, 0, 0, Z, A, Z, 0, 0, 0, 0 ],     #
         [ 0, 0, 0, 0, Z, A, Z, 0, 0, 0, 0 ],     #
         [ 0, 0, 0, 0, pA4, A, pA6, 0, 0, 0, 0 ], #
        ])
        
        dist = (2, 4)
        frame = self.build_frame(grid=grid, dist=dist)
        frame.set_goal(5, 0)
        self.check_expected_obtained_grid(frame, expected)    

    def test_curve_margins(self):
        grid = np.array([
            # 0  1  2  3  4  5  6  7  8  9  10
            [ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1 ], #
            [ 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1 ], #
            [ 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1 ], #
            [ 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 ], #
            [ 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1 ], #
            [ 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1 ], #
            [ 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1 ], #
            [ 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1 ], #
            [ 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1 ], #
            [ 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1 ], #
            [ 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1 ], #
        ])
        
        p02 = SearchFrame.HEADING_MINUS_45 | SearchFrame.HEADING_MINUS_67_5 | SearchFrame.HEADING_MINUS_22_5
        p03 = SearchFrame.HEADING_MINUS_45 | SearchFrame.HEADING_MINUS_22_5 | SearchFrame.HEADING_45 | SearchFrame.HEADING_22_5 | SearchFrame.HEADING_0
        L = SearchFrame.HEADING_MINUS_67_5 | SearchFrame.HEADING_MINUS_45 | SearchFrame.HEADING_MINUS_22_5
        Z = SearchFrame.HEADING_0
        A = 0xff
        p45 = SearchFrame.HEADING_MINUS_45 | SearchFrame.HEADING_MINUS_22_5 | SearchFrame.HEADING_0
        pA5 = SearchFrame.HEADING_45 | SearchFrame.HEADING_22_5 | SearchFrame.HEADING_0
        pA7 = SearchFrame.HEADING_MINUS_45 | SearchFrame.HEADING_MINUS_22_5 | SearchFrame.HEADING_0
        
        expected = np.array([
         # 0  1  2  3  4  5  6  7  8  9  10
            [ 0, 0, p02, p03, 0, 0, 0, 0, 0, 0, 0 ], #0
            [ 0, 0, 0, L, 0, 0, 0, 0, 0, 0, 0 ],     #1
            [ 0, 0, 0, 0, L, 0, 0, 0, 0, 0, 0 ],     #2
            [ 0, 0, 0, 0, 0, L, 0, 0, 0, 0, 0 ],     #3
            [ 0, 0, 0, 0, 0, p45, L, 0, 0, 0, 0 ],   #4
            [ 0, 0, 0, 0, 0, Z, A, 0, 0, 0, 0 ],     #5
            [ 0, 0, 0, 0, 0, Z, A, Z, 0, 0, 0 ],     #6
            [ 0, 0, 0, 0, 0, Z, A, Z, 0, 0, 0 ],     #7
            [ 0, 0, 0, 0, 0, Z, A, Z, 0, 0, 0 ],     #8
            [ 0, 0, 0, 0, 0, Z, A, Z, 0, 0, 0 ],     #9
            [ 0, 0, 0, 0, 0, pA5, A, pA7, 0, 0, 0 ]  #10
        ])
        
        dist = (2, 4)
        frame = self.build_frame(grid=grid, dist=dist)
        frame.set_goal(5, 0)
        self.check_expected_obtained_grid(frame, expected)    
        
if __name__ == "__main__":
    unittest.main()
