import sys
sys.path.append("..")
sys.path.append("../../")
sys.path.append("../../../")
import unittest, math
from model.waypoint import Waypoint
import numpy as np
from utils.cudac.cuda_frame import *

def compute_euclidian_distance (x1: float, y1: float, x2: float, y2: float) -> float:
    dx = x2 - x1
    dy = y2 - y1
    return math.sqrt(dx * dx + dy * dy)

def convertToBoolStr(p):
    if (p == 1 or p == 1.0):
        return "true"
    return "false"


def convertToStr(p):
    HEADING_90 = int(GridDirection.HEADING_90.value)
    HEADING_45 = int(GridDirection.HEADING_45.value)
    HEADING_0 = int(GridDirection.HEADING_0.value)
    HEADING_MINUS_45 = int(GridDirection.HEADING_MINUS_45.value)

    p = int(p)
    res = ""
    if p & HEADING_0 > 0:
        res += "0 "
    if p & HEADING_90 > 0:
        res += "90 "
    if p & HEADING_45 > 0:
        res += "45 "
    if p & HEADING_MINUS_45 > 0:
        res += "-45 "
    return res
        
        
class TestSetGoal(unittest.TestCase): 
    def test_distance_feasibility(self):
        frame = np.array([
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
        ], dtype=np.float32)

        feasible_expect = np.array([
            [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
            [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
            [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
            [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
            [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
            [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
            [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
            [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
            [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
            [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
            [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0]
        ], dtype=np.float32)

        goal = Waypoint(5, 0)
        og = CudaFrame(frame, 0, 0, Waypoint(0,0), Waypoint(-1,-1))
        og.set_goal(goal)
        f = og.get_frame()

        for i in range(f.shape[0]):
            for j in range(f.shape[1]):
                self.assertEqual(f[i, j, 2], feasible_expect[i, j], f"pos: ({i}, {j}) - feasible: {convertToBoolStr(f[i, j, 2])}, expected: {convertToBoolStr(feasible_expect[i, j])}")
                expected_dist = compute_euclidian_distance(j, i, goal.x, goal.z)
                if feasible_expect[i, j] == 1:
                    self.assertAlmostEqual(f[i, j, 1], expected_dist, places=4, msg=f"not valid for ({i},{j}): computed: {f[i, j, 1]}, expected: {expected_dist}")

    def test_distance_feasibility_minimal_dist(self):
        frame = np.array([
            [[0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0]]
        ], dtype=np.float32)


        feasible_expect = np.array([
            [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0]
        ], dtype=np.float32)
        
        goal = Waypoint(5, 0)
        og = CudaFrame(frame, 6, 6, Waypoint(0,0), Waypoint(-1,-1))
        og.set_goal(goal)
        f = og.get_frame()


        for i in range(f.shape[0]):
            for j in range(f.shape[1]):
                self.assertEqual(f[i, j, 2], feasible_expect[i, j], f"pos: ({i}, {j}) - feasible: {convertToBoolStr(f[i, j, 2])}, expected: {convertToBoolStr(feasible_expect[i, j])}")
                expected_dist = compute_euclidian_distance(j, i, goal.x, goal.z)
                if feasible_expect[i, j] == 1:
                    self.assertAlmostEqual(f[i, j, 1], expected_dist, places=4, msg=f"not valid for ({i},{j}): computed: {f[i, j, 1]}, expected: {expected_dist}")

    def test_distance_feasibility_curved(self):
        frame = np.array([
            [[24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
        ], dtype=np.float32)

        feasible_expect = np.array([
            [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
            [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
            [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0],

            [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
            [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0]
        ], dtype=np.float32)

        goal = Waypoint(5, 0)
        og = CudaFrame(frame, 0, 0, Waypoint(0,0), Waypoint(-1,-1))
        og.set_goal(goal)
        f = og.get_frame()

        for i in range(f.shape[0]):
            for j in range(f.shape[1]):
                self.assertEqual(f[i, j, 2], feasible_expect[i, j], f"pos: ({i}, {j}) - feasible: {convertToBoolStr(f[i, j, 2])}, expected: {convertToBoolStr(feasible_expect[i, j])}")
                expected_dist = compute_euclidian_distance(j, i, goal.x, goal.z)
                if feasible_expect[i, j] == 1:
                    self.assertAlmostEqual(f[i, j, 1], expected_dist, places=4, msg=f"not valid for ({i},{j}): computed: {f[i, j, 1]}, expected: {expected_dist}")

    

    def test_distance_feasibility_curved_minimal_dist(self):
        frame = np.array([
            [[24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
        ], dtype=np.float32)

        feasible_expect = np.array([
            [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]
        ], dtype=np.float32)

        goal = Waypoint(5, 0)
        og = CudaFrame(frame, 2, 2, Waypoint(0,0), Waypoint(-1,-1))
        og.set_goal(goal)
        f = og.get_frame()

        for i in range(f.shape[0]):
            for j in range(f.shape[1]):
                
                self.assertEqual(f[i, j, 2], feasible_expect[i, j], f"pos: ({i}, {j}) - feasible: {convertToBoolStr(f[i, j, 2])}, expected: {convertToBoolStr(feasible_expect[i, j])}")
                expected_dist = compute_euclidian_distance(j, i, goal.x, goal.z)
                if feasible_expect[i, j] == 1:
                    self.assertAlmostEqual(f[i, j, 1], expected_dist, places=4, msg=f"not valid for ({i},{j}): computed: {f[i, j, 1]}, expected: {expected_dist}")

class TestSetVectorizedGoal(unittest.TestCase): 
    
    def test_vector_feasible_no_min_dist(self):
        ALL = int(GridDirection.ALL.value)

        frame = np.array([
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
        ], dtype=np.float32)

        feasible_expect = np.array([
            [0, 0, 0, ALL, ALL, ALL, ALL, ALL, 0, 0, 0],
            [0, 0, 0, ALL, ALL, ALL, ALL, ALL, 0, 0, 0],
            [0, 0, 0, ALL, ALL, ALL, ALL, ALL, 0, 0, 0],
            [0, 0, 0, ALL, ALL, ALL, ALL, ALL, 0, 0, 0],
            [0, 0, 0, ALL, ALL, ALL, ALL, ALL, 0, 0, 0],
            [0, 0, 0, ALL, ALL, ALL, ALL, ALL, 0, 0, 0],
            [0, 0, 0, ALL, ALL, ALL, ALL, ALL, 0, 0, 0],
            [0, 0, 0, ALL, ALL, ALL, ALL, ALL, 0, 0, 0],
            [0, 0, 0, ALL, ALL, ALL, ALL, ALL, 0, 0, 0],
            [0, 0, 0, ALL, ALL, ALL, ALL, ALL, 0, 0, 0],
            [0, 0, 0, ALL, ALL, ALL, ALL, ALL, 0, 0, 0]
        ], dtype=np.float32)

        goal = Waypoint(5, 0)
        og = CudaFrame(frame, 0, 0, Waypoint(0,0), Waypoint(-1,-1))
        og.set_goal_vectorized(goal)
        f = og.get_frame()

        for i in range(f.shape[0]):
            for j in range(f.shape[1]):
                f[i, j, 2] = round(f[i, j, 2])
                self.assertEqual(f[i, j, 2], feasible_expect[i, j], f"pos: ({i}, {j}) - feasible: {convertToStr(f[i, j, 2])}, expected: {convertToStr(feasible_expect[i, j])}")
                expected_dist = compute_euclidian_distance(j, i, goal.x, goal.z)
                if feasible_expect[i, j] == 1:
                    self.assertAlmostEqual(f[i, j, 1], expected_dist, places=4, msg=f"not valid for ({i},{j}): computed: {f[i, j, 1]}, expected: {expected_dist}")

    def test_vector_feasible_min_x(self):
        return
        frame = np.array([
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
        ], dtype=np.float32)

        ALL = int(GridDirection.ALL.value)
        HEADING_45 = int(GridDirection.HEADING_45.value)
        HEADING_90 = int(GridDirection.HEADING_90.value)
        HEADING_MINUS_45 = int(GridDirection.HEADING_MINUS_45.value)
        
        feasible_expect = np.array([
            [0, 0, 0, HEADING_45 | HEADING_90, ALL, ALL, ALL, HEADING_MINUS_45 | HEADING_90, 0, 0, 0],
            [0, 0, 0, HEADING_90, ALL, ALL, ALL, HEADING_90, 0, 0, 0],
            [0, 0, 0, HEADING_90, ALL, ALL, ALL, HEADING_90, 0, 0, 0],
            [0, 0, 0, HEADING_90, ALL, ALL, ALL, HEADING_90, 0, 0, 0],
            [0, 0, 0, HEADING_90, ALL, ALL, ALL, HEADING_90, 0, 0, 0],
            [0, 0, 0, HEADING_90, ALL, ALL, ALL, HEADING_90, 0, 0, 0],
            [0, 0, 0, HEADING_90, ALL, ALL, ALL, HEADING_90, 0, 0, 0],
            [0, 0, 0, HEADING_90, ALL, ALL, ALL, HEADING_90, 0, 0, 0],
            [0, 0, 0, HEADING_90, ALL, ALL, ALL, HEADING_90, 0, 0, 0],
            [0, 0, 0, HEADING_90, ALL, ALL, ALL, HEADING_90, 0, 0, 0],
            [0, 0, 0, HEADING_MINUS_45 | HEADING_90, ALL, ALL, ALL, HEADING_45 | HEADING_90, 0, 0, 0]
        ], dtype=np.float32)

        goal = Waypoint(5, 0)
        og = CudaFrame(frame, 2, 0, Waypoint(1000,1000), Waypoint(1000,1000))
        og.set_goal_vectorized(goal)
        f = og.get_frame()

        for i in range(f.shape[0]):
            for j in range(f.shape[1]):
                f[i, j, 2] = round(f[i, j, 2])
                self.assertEqual(f[i, j, 2], feasible_expect[i, j], f"pos: ({i}, {j}) - feasible: {convertToStr(f[i, j, 2])}, expected: {convertToStr(feasible_expect[i, j])}")
                expected_dist = compute_euclidian_distance(j, i, goal.x, goal.z)
                if feasible_expect[i, j] == 1:
                    self.assertAlmostEqual(f[i, j, 1], expected_dist, places=4, msg=f"not valid for ({i},{j}): computed: {f[i, j, 1]}, expected: {expected_dist}")

    def test_vector_feasible_min_z(self):
        return
        frame = np.array([
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
        ], dtype=np.float32)

        ALL = int(GridDirection.ALL.value)
        HEADING_45 = int(GridDirection.HEADING_45.value)
        HEADING_0 = int(GridDirection.HEADING_0.value)
        HEADING_MINUS_45 = int(GridDirection.HEADING_MINUS_45.value)

        feasible_expect = np.array([
            [0, 0, 0, HEADING_0 | HEADING_MINUS_45, ALL, ALL, ALL, HEADING_45 | HEADING_0, 0, 0, 0],
            [0, 0, 0, HEADING_0, ALL, ALL, ALL, HEADING_0, 0, 0, 0],
            [0, 0, 0, HEADING_0, ALL, ALL, ALL, HEADING_0, 0, 0, 0],
            [0, 0, 0, HEADING_0, ALL, ALL, ALL, HEADING_0, 0, 0, 0],
            [0, 0, 0, HEADING_0, ALL, ALL, ALL, HEADING_0, 0, 0, 0],
            [0, 0, 0, HEADING_0, ALL, ALL, ALL, HEADING_0, 0, 0, 0],
            [0, 0, 0, HEADING_0, ALL, ALL, ALL, HEADING_0, 0, 0, 0],
            [0, 0, 0, HEADING_0, ALL, ALL, ALL, HEADING_0, 0, 0, 0],
            [0, 0, 0, HEADING_0, ALL, ALL, ALL, HEADING_0, 0, 0, 0],
            [0, 0, 0, HEADING_0, ALL, ALL, ALL, HEADING_0, 0, 0, 0],
            [0, 0, 0, HEADING_0 | HEADING_45 , ALL, ALL, ALL, HEADING_MINUS_45 | HEADING_0, 0, 0, 0]
        ], dtype=np.float32)

        goal = Waypoint(5, 0)
        og = CudaFrame(frame, 0, 2, Waypoint(1000,1000), Waypoint(1000,1000))
        og.set_goal_vectorized(goal)
        f = og.get_frame()

        for i in range(f.shape[0]):
            for j in range(f.shape[1]):
                f[i, j, 2] = round(f[i, j, 2])
                self.assertEqual(f[i, j, 2], feasible_expect[i, j], f"pos: ({i}, {j}) - feasible: {convertToStr(f[i, j, 2])}, expected: {convertToStr(feasible_expect[i, j])}")
                expected_dist = compute_euclidian_distance(j, i, goal.x, goal.z)
                if feasible_expect[i, j] == 1:
                    self.assertAlmostEqual(f[i, j, 1], expected_dist, places=4, msg=f"not valid for ({i},{j}): computed: {f[i, j, 1]}, expected: {expected_dist}")

    def test_vector_feasible_min_xz(self):
        frame = np.array([
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
        ], dtype=np.float32)
        
        ALL = int(GridDirection.ALL.value)

        feasible_expect = np.array([
            [0, 0, 0, 0, ALL, ALL, ALL, 0, 0, 0, 0],
            [0, 0, 0, 0, ALL, ALL, ALL, 0, 0, 0, 0],
            [0, 0, 0, 0, ALL, ALL, ALL, 0, 0, 0, 0],
            [0, 0, 0, 0, ALL, ALL, ALL, 0, 0, 0, 0],
            [0, 0, 0, 0, ALL, ALL, ALL, 0, 0, 0, 0],
            [0, 0, 0, 0, ALL, ALL, ALL, 0, 0, 0, 0],
            [0, 0, 0, 0, ALL, ALL, ALL, 0, 0, 0, 0],
            [0, 0, 0, 0, ALL, ALL, ALL, 0, 0, 0, 0],
            [0, 0, 0, 0, ALL, ALL, ALL, 0, 0, 0, 0],
            [0, 0, 0, 0, ALL, ALL, ALL, 0, 0, 0, 0],
            [0, 0, 0, 0, ALL, ALL, ALL, 0, 0, 0, 0]
        ], dtype=np.float32)

        goal = Waypoint(5, 0)
        og = CudaFrame(frame, 2, 2, Waypoint(1000,1000), Waypoint(1000,1000))
        og.set_goal_vectorized(goal)
        f = og.get_frame()

        for i in range(f.shape[0]):
            for j in range(f.shape[1]):
                f[i, j, 2] = round(f[i, j, 2])
                self.assertEqual(f[i, j, 2], feasible_expect[i, j], f"pos: ({i}, {j}) - feasible: {convertToStr(f[i, j, 2])}, expected: {convertToStr(feasible_expect[i, j])}")
                expected_dist = compute_euclidian_distance(j, i, goal.x, goal.z)
                if feasible_expect[i, j] == 1:
                    self.assertAlmostEqual(f[i, j, 1], expected_dist, places=4, msg=f"not valid for ({i},{j}): computed: {f[i, j, 1]}, expected: {expected_dist}")

class TestPathFeasible(unittest.TestCase): 
    
    def test_path_feasible_min_xz_all_ok(self):
        frame = np.array([
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
        ], dtype=np.float32)
        
        
        path = [
            Waypoint(4, 0),
            Waypoint(5, 1),
            Waypoint(5, 2),
            Waypoint(5, 3),
            Waypoint(5, 4),
            Waypoint(6, 5),
            Waypoint(5, 6),
            Waypoint(4, 7),
            Waypoint(4, 8),
            Waypoint(4, 9),
            Waypoint(5, 10),
        ]
        
        # force GPU usage to test the GPU impl
        for k in range(1000):
            path.append(Waypoint(0,0))

        og = CudaFrame(frame, 2, 2, Waypoint(1000,1000), Waypoint(1000,1000))
        feasible = og.compute_feasible_path(path)

        i = 11
        for f in feasible:
            self.assertTrue(f)
            i -= 1
            if i == 0: break

    def test_path_feasible_min_xz_some_non_feasible(self):
        frame = np.array([
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
        ], dtype=np.float32)
        
        
        path = [
            Waypoint(4, 0),
            Waypoint(5, 1),
            Waypoint(7, 2),  # non-feasible
            Waypoint(5, 3),
            Waypoint(5, 4),
            Waypoint(3, 5),  # non-feasible
            Waypoint(5, 6),
            Waypoint(4, 7),
            Waypoint(4, 8),
            Waypoint(1, 9),   # non-feasible
            Waypoint(5, 10),
        ]
        
         # force GPU usage to test the GPU impl
        for k in range(1000):
            path.append(Waypoint(0,0))


        og = CudaFrame(frame, 2, 2, Waypoint(1000,1000), Waypoint(1000,1000))
        feasible = og.compute_feasible_path(path)

        for i in range(len(path)):
            if i >= 11: break
            if i == 2 or i == 5 or i == 9: 
                self.assertFalse(feasible[i])
            else:
                self.assertTrue(feasible[i])
            
   
    def test_path_feasible_min_xz_all_ok_CPU(self):
        frame = np.array([
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
        ], dtype=np.float32)
        
        
        path = [
            Waypoint(4, 0),
            Waypoint(5, 1),
            Waypoint(5, 2),
            Waypoint(5, 3),
            Waypoint(5, 4),
            Waypoint(6, 5),
            Waypoint(5, 6),
            Waypoint(4, 7),
            Waypoint(4, 8),
            Waypoint(4, 9),
            Waypoint(5, 10),
            Waypoint(0, 0),
            Waypoint(0, 0)
        ]
        
        og = CudaFrame(frame, 2, 2, Waypoint(1000,1000), Waypoint(1000,1000))
        feasible = og.compute_feasible_path(path)

        i = 11
        for f in feasible:
            self.assertTrue(f, f"path not true for {path[11-i]}")
            i -= 1
            if i == 0: break

    def test_path_feasible_min_xz_some_non_feasible_CPU(self):
        frame = np.array([
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
            [[0, 0, 0], [0, 0, 0], [0, 0, 0], [24, 0, 0], [25, 0, 0], [25, 0, 0], [25, 0, 0], [24, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
        ], dtype=np.float32)
        
        
        path = [
            Waypoint(4, 0),
            Waypoint(5, 1),
            Waypoint(7, 2),  # non-feasible
            Waypoint(5, 3),
            Waypoint(5, 4),
            Waypoint(3, 5),  # non-feasible
            Waypoint(5, 6),
            Waypoint(4, 7),
            Waypoint(4, 8),
            Waypoint(1, 9),   # non-feasible
            Waypoint(5, 10),
        ]
    
        og = CudaFrame(frame, 2, 2, Waypoint(1000,1000), Waypoint(1000,1000))
        feasible = og.compute_feasible_path(path)

        for i in range(len(path)):
            if i >= 11: break
            if i == 2 or i == 5 or i == 9: 
                self.assertFalse(feasible[i], f"pos {i} should be not feasible")
            else:
                self.assertTrue(feasible[i], f"pos {i} should be feasible")



if __name__ == "__main__":
    unittest.main()