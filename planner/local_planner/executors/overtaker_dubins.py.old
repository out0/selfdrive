from model.waypoint import Waypoint
from planner.local_planner.local_planner_executor import LocalPathPlannerExecutor
from planner.local_planner.local_planner import PlanningData, PlanningResult, PlannerResultType
from threading import Thread
from planner.local_planner.executors.waypoint_interpolator import WaypointInterpolator
from vision.occupancy_grid_cuda import GridDirection
import math, numpy as np
from planner.local_planner.executors.dubins_curves import Dubins
from planner.local_planner.executors.waypoint_interpolator import WaypointInterpolator
from model.physical_parameters import PhysicalParameters
from .debug_dump import dump_result

DEBUG_DUMP = True

class OvertakerPlanner(LocalPathPlannerExecutor):

    INSIDE = 0  # 0000
    LEFT = 1    # 0001
    RIGHT = 2   # 0010
    BOTTOM = 4  # 0100
    TOP = 8     # 1000

    _plan_task: Thread
    _search: bool
    _planner_data: PlanningData
    _result: PlanningResult
    _step_size: int
    _dubins: Dubins

    NAME = "overtaker"

    def __init__(self, 
                 max_exec_time_ms: int, 
                 step_size: int) -> None:
        
        super().__init__(max_exec_time_ms)
        self._step_size = step_size
        self._dubins = Dubins(40, 4)


    def plan(self, planner_data: PlanningData, partial_result: PlanningResult) -> None:
        self._og = planner_data.og
        self._planner_data = planner_data
        self._search = True
        self._result = partial_result
        self._plan_task = Thread(target=self.__perform_local_planning)
        self._plan_task.start()

    def cancel(self) -> None:
        self._search = False
        self._plan_task = None

    def is_planning(self) -> bool:
        return self._search

    def get_result(self) -> PlanningResult:
        return self._result

    def __check_path_feasible(self, path: list[Waypoint]) -> bool:
        if path is None or len(path) <= 2:
            return False
        
        return self._planner_data.og.check_all_path_feasible(path)
    
    # def __dump_to_tmp(frame: np.ndarray, path: List[Waypoint], color = [255, 255, 255]):
    #     new_f = np.zeros(frame.shape)
    #     for i in range (frame.shape[0]):
    #         for j in range (frame.shape[1]):
    #             new_f[i, j, 0] = frame[i, j, 0]
    #             new_f[i, j, 1] = frame[i, j, 1]
    #             new_f[i, j, 2] = frame[i, j, 2]
                
    #     for p in path:
    #         frame[p.z, p.x, :] = color
    #     cv2.imwrite("overtake_tmp.png", frame)


    def __perform_local_planning(self) -> None:
        self._result.planner_name = OvertakerPlanner.NAME
        self._result.result_type = PlannerResultType.INVALID_PATH
        self.set_exec_started()
        self._rst_timeout()

        start = self._result.local_start
        goal = Waypoint(self._result.local_goal.x,
                        self._result.local_goal.z)


        if self.__try_direct_path(goal):
            dump_result(self._og, self._result)
            self._result.result_type = PlannerResultType.VALID
            self._result.total_exec_time_ms = self.get_execution_time()
            self._search = False
        
        # if fails, try relocating the goal point       
        try_left_first = self._result.local_goal.x < start.x
        
        if try_left_first:
            if self.__relocate_left(goal):
                self._result.result_type = PlannerResultType.VALID
                self._result.total_exec_time_ms = self.get_execution_time()
                self._search = False
                return
            if self.__relocate_right(goal):
                self._result.result_type = PlannerResultType.VALID
                self._result.total_exec_time_ms = self.get_execution_time()
                self._search = False
                return
        else:
            if self.__relocate_right(goal):
                self._result.result_type = PlannerResultType.VALID
                self._result.total_exec_time_ms = self.get_execution_time()
                self._search = False
                return
            if self.__relocate_left(goal):
                self._result.result_type = PlannerResultType.VALID
                self._result.total_exec_time_ms = self.get_execution_time()
                self._search = False
                return
        
        self._result.result_type = PlannerResultType.INVALID_PATH
        self._result.total_exec_time_ms = self.get_execution_time()
        self._search = False
    
    def __find_first_feasible_goal(self, z: int, x_init: int, x_limit: int) -> int:
        inc = 1
        if x_init > x_limit:
            inc = -1
        
        for i in range(x_init, x_limit, inc):
            if self._og.check_direction_allowed(i, z, GridDirection.HEADING_0):
                return i
        return -1
    
    def __try_direct_path(self, goal: Waypoint):
        start = self._result.local_start
        if start.x == goal.x:
            # try going straight first        
            self._result.path = WaypointInterpolator.interpolate_straight_line_path2(start, goal,  self._og.width, self._og.height, 20)
        else:
            self._result.path = self._dubins.build_path(start, goal, self._og.width(), self._og.height())
        
        if DEBUG_DUMP:
                dump_result(self._og, self._result)
        
        return self.__check_path_feasible(self._result.path)
    
    def __relocate_left(self, goal: Waypoint) -> bool:
        
        x_min = self.__find_first_feasible_goal(goal.z, 0, goal.x)
        
        if x_min < 0:
            return False
        
        x = math.floor(0.5 * (goal.x + x_min))
        
        if x < x_min or x > goal.x:
            return False

        new_goal = Waypoint(x, goal.z, 0)
        self._result.path = self._dubins.build_path(self._result.local_start, new_goal, self._og.width(), self._og.height())
        
        if DEBUG_DUMP:
            dump_result(self._og, self._result)
            
        if self._og.check_all_path_feasible(self._result.path):
            return True
        
        return self.__relocate_step_left(goal, 2, x_min)
    
    def __relocate_right(self, goal: Waypoint) -> bool:
        
        x_max = self.__find_first_feasible_goal(goal.z, goal.x, self._og.width())
        
        if x_max < 0:
            return False
        
        x = math.floor(0.5 * (goal.x + x_max))
        
        if x < goal.x or x > x_max:
            return False

        new_goal = Waypoint(x, goal.z, 0)
        self._result.path = self._dubins.build_path(self._result.local_start, new_goal, self._og.width(), self._og.height())
        
        if DEBUG_DUMP:
            dump_result(self._og, self._result)
            
        if self._og.check_all_path_feasible(self._result.path):
            return True
        
        return self.__relocate_step_right(goal, 2, x_max)
    
    def __relocate_step_left(self, goal: Waypoint, step: int, x_min: int) -> bool:
        
        if x_min < 0:
            return False
        
        x = goal.x - step
        
        if x < x_min:
            return False

        new_goal = Waypoint(x, goal.z, 0)
        self._result.path = self._dubins.build_path(self._result.local_start, new_goal, self._og.width(), self._og.height())
        
        if DEBUG_DUMP:
            dump_result(self._og, self._result)
            
        if self._og.check_all_path_feasible(self._result.path):
            return True
        
        self.__relocate_step_left(new_goal, step, x_min)
            
    def __relocate_step_right(self, goal: Waypoint, step: int, x_max: int) -> bool:

        if x_max < 0:
            return False
        
        x = goal.x + step
        
        if x >= x_max:
            return False

        new_goal = Waypoint(x, goal.z, 0)      
        self._result.path = self._dubins.build_path(self._result.local_start, new_goal, self._og.width(), self._og.height())
        
        if DEBUG_DUMP:
            dump_result(self._og, self._result)
            
        if self._og.check_all_path_feasible(self._result.path):
            return True
        
        self.__relocate_step_right(new_goal, step, x_max)        
    
   